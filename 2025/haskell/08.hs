-- This code is generated by ClaudeCode.
module Main08 where

import Data.List (sortBy)
import Data.IntMap.Strict (IntMap)
import qualified Data.IntMap.Strict as IM
import Data.Ord (comparing)

type Point = (Int, Int, Int)
type Edge = (Int, Int, Double)

-- Parse a line like "162,817,812" into a Point
parsePoint :: String -> Point
parsePoint s = case map read (splitOn ',' s) of
    [x, y, z] -> (x, y, z)
    _ -> error "Invalid point format"
  where
    splitOn :: Char -> String -> [String]
    splitOn c str = case dropWhile (== c) str of
        "" -> []
        s' -> w : splitOn c s''
            where (w, s'') = break (== c) s'

-- Calculate Euclidean distance between two points
distance :: Point -> Point -> Double
distance (x1, y1, z1) (x2, y2, z2) =
    sqrt $ fromIntegral ((x2-x1)^2 + (y2-y1)^2 + (z2-z1)^2)

-- Generate all edges with their distances
generateEdges :: [Point] -> [Edge]
generateEdges points =
    [(i, j, distance pi pj) |
     (i, pi) <- indexed,
     (j, pj) <- indexed,
     i < j]
  where
    indexed = zip [0..] points

-- Union-Find data structure
data UnionFind = UF
    { parent :: IntMap Int
    , rank :: IntMap Int
    } deriving Show

-- Initialize Union-Find with n elements
makeUF :: Int -> UnionFind
makeUF n = UF
    { parent = IM.fromList [(i, i) | i <- [0..n-1]]
    , rank = IM.fromList [(i, 0) | i <- [0..n-1]]
    }

-- Find root without path compression (for pure query)
findRoot :: Int -> UnionFind -> Int
findRoot x uf =
    let px = parent uf IM.! x
    in if px == x then x else findRoot px uf

-- Find with path compression
find :: Int -> UnionFind -> (Int, UnionFind)
find x uf =
    let px = parent uf IM.! x
    in if px == x
       then (x, uf)
       else let (root, uf') = find px uf
            in (root, uf' { parent = IM.insert x root (parent uf') })

-- Union by rank
union :: Int -> Int -> UnionFind -> (Bool, UnionFind)
union x y uf =
    let (rx, uf1) = find x uf
        (ry, uf2) = find y uf1
    in if rx == ry
       then (False, uf2)  -- Already in same set
       else let rankX = rank uf2 IM.! rx
                rankY = rank uf2 IM.! ry
            in if rankX > rankY
               then (True, uf2 { parent = IM.insert ry rx (parent uf2) })
               else if rankX < rankY
                    then (True, uf2 { parent = IM.insert rx ry (parent uf2) })
                    else (True, uf2 { parent = IM.insert ry rx (parent uf2)
                                    , rank = IM.insert rx (rankX + 1) (rank uf2) })

-- Process edges and attempt numEdges edge attempts (not just successful connections)
processEdges :: Int -> [Edge] -> UnionFind -> UnionFind
processEdges _ [] uf = uf
processEdges 0 _ uf = uf
processEdges n ((i, j, _):es) uf =
    let (_, uf') = union i j uf
    in processEdges (n-1) es uf'

-- Get all component sizes using findRoot (no state threading needed)
getComponentSizes :: Int -> UnionFind -> [Int]
getComponentSizes n uf =
    let roots = map (\i -> findRoot i uf) [0..n-1]
        -- Count occurrences of each root
        countMap = foldr (\r m -> IM.insertWith (+) r 1 m) IM.empty roots
    in IM.elems countMap

-- Process edges until all nodes are in one component
-- Returns the last edge that connected two different components
processUntilConnected :: Int -> [Edge] -> UnionFind -> Maybe Edge
processUntilConnected n edges uf = go edges uf Nothing
  where
    go [] _ lastEdge = lastEdge
    go ((i, j, d):es) uf' lastEdge =
        let (connected, uf'') = union i j uf'
            newLast = if connected then Just (i, j, d) else lastEdge
            -- Count number of components
            sizes = getComponentSizes n uf''
        in if length sizes == 1
           then newLast  -- All connected, return the last connecting edge
           else go es uf'' newLast

solvePart1 :: String -> Int
solvePart1 input =
    let points = map parsePoint $ lines input
        n = length points
        edges = sortBy (comparing (\(_, _, d) -> d)) $ generateEdges points
        uf = makeUF n
        finalUF = processEdges 1000 edges uf
        sizes = getComponentSizes n finalUF
        top3 = take 3 $ sortBy (flip compare) sizes
    in product top3

solvePart2 :: String -> Int
solvePart2 input =
    let points = map parsePoint $ lines input
        n = length points
        edges = sortBy (comparing (\(_, _, d) -> d)) $ generateEdges points
        uf = makeUF n
        pointsList = map parsePoint $ lines input
    in case processUntilConnected n edges uf of
        Nothing -> error "Never connected all components"
        Just (i, j, _) ->
            let (x1, _, _) = pointsList !! i
                (x2, _, _) = pointsList !! j
            in x1 * x2

main :: IO ()
main = do
    input <- readFile "08.input"
    let points = map parsePoint $ lines input
    let n = length points
    let edges = sortBy (comparing (\(_, _, d) -> d)) $ generateEdges points
    let uf = makeUF n

    -- Part 1
    let finalUF = processEdges 1000 edges uf
    let sizes = getComponentSizes n finalUF
    let sorted = sortBy (flip compare) sizes
    putStrLn "=== Part 1 ==="
    putStrLn $ "Number of components: " ++ show (length sizes)
    putStrLn $ "Top 3 sizes: " ++ show (take 3 sorted)
    putStrLn $ "Part 1 answer: " ++ show (product (take 3 sorted))

    -- Part 2
    putStrLn "\n=== Part 2 ==="
    putStrLn $ "Part 2 answer: " ++ show (solvePart2 input)
